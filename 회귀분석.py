# -*- coding: utf-8 -*-
"""회귀분석.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1siqOGlz0lHQ655Ljf4fmPWYZl9sD84FN
"""

# Commented out IPython magic to ensure Python compatibility.
import warnings
warnings.filterwarnings('ignore')
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

import os, sys 
from google.colab import drive 

drive.mount('/content/gdrive')

default_dir = "/content/gdrive/My Drive"
app_train = pd.read_csv(os.path.join(default_dir, 'FIFA_train.csv'))
app_test = pd.read_csv(os.path.join(default_dir, 'FIFA_test.csv'))

def get_apps_dataset():
    default_dir = "/content/gdrive/My Drive"
    app_train = pd.read_csv(os.path.join(default_dir, 'FIFA_train.csv'))
    app_test = pd.read_csv(os.path.join(default_dir, 'FIFA_test.csv'))
    apps = pd.concat([app_train, app_test])
    
    return apps

apps = get_apps_dataset()

apps.info()
# continent, position, prefer_foot은 명목변수 / reputation, stat_skill_moves는 순위변수 / - 더미변수화 필요 
# id, name, contract_until과 같은 변수는 필요없어보임
# value 변수를 보면 8932개로 12760 - 8932 = 3828개의 NA값이 있음 - 평균으로 대체 또는 제거 필요

# 범주형 변수들에 대해서 각각 가지는 unique 값 확인
name = ['continent', 'position', 'prefer_foot', 'reputation', 'stat_skill_moves']
for i in name:
  print('{}:'.format(i), apps[i].unique(), '\n')

# 범주형 변수들의 unique한 값들이 어떻게 분포되어 있는지 확인
name = ['continent', 'position', 'prefer_foot', 'reputation', 'stat_skill_moves']

for i in name:
  print(apps.loc[:, i].value_counts(), '\n')

# 위의 범주형 변수들을 제외하고 이산형 변수들에 대해 기초통계량 확인
data[['age','stat_overall','stat_potential','value']].describe()

# value변수의 mean이 제 3사분위수에 해당하는 값으로 median에 비해서 상당히 오른쪽에 위치, 즉 right-skewed한 분포를 보일 것이라고 예상 가능

# value변수에 대한 커널밀도추정
a = apps['value']
plt.figure(figsize=(8,8))
ax = sns.distplot(a)
ax.set_title('KDE of value', size=20)
plt.show()

# id, name, contract_until 변수 제거 및 결측치 평균값으로 대체
data = apps.drop(['id', 'name', 'contract_until'], axis=1)
data = data.fillna(data.value.mean())
data.isna().sum()

# 연속형변수들에 대해 box-plot으로 outliers로 의심되는 값들 확인
b = ['age','stat_overall','stat_potential','value']
fig, axes = plt.subplots(2,2, figsize=(12,12))
for idx, ax in enumerate(axes.flat):
  ax.boxplot(data[b[idx]])
  ax.set_title(b[idx], size=20)
fig.tight_layout()

# 위의 boxplot의 단점을 보완한 violinplot
ft_name = ['age', 'stat_overall', 'stat_potential', 'value' ]
sns.set(rc = {'figure.figsize':(12,20)})
fig, axs = plt.subplots(nrows = 4, ncols=1)
axs = axs.flat
for i,name in enumerate(ft_name):
  a = sns.violinplot(x=name, data=data, ax=axs[i])
  a.set_title('violinplot of {}'.format(name))
fig.tight_layout()

# 위의 violinplot으로 확인한 분포의 모양을 이번에는 커널밀도추정으로 확인
b = ['age','stat_overall','stat_potential','value']


for name in b:
  sns.displot(data[name], kind='kde', height=7)
  plt.show()
  print('\n')

# 종속변수 value와 다음의 변수들이 어떠한 선형관계가 있는지를 시각적으로 확안
ft_name = ['age', 'reputation', 'stat_overall', 'stat_potential', 'stat_skill_moves']
sns.set(rc = {'figure.figsize':(8,8)})

for i, ft in enumerate(ft_name):
  sns.regplot(x=ft, y='value', data=data)
  plt.show()
  print('\n')

# 변수간 상관관계 

corr_df = data[['stat_overall','stat_potential','value', 'stat_skill_moves', 'reputation']].corr()
corr_df

# 변수간 상관관계  시각화

plt.figure(figsize=(10,10))
ax = sns.heatmap(corr_df, annot=True, fmt='.3f')
ax.tick_params(labelsize=15, length=10, width=3)
plt.show()

# 'continent', 'position', 'prefer_foot', 'reputation','stat_skill_moves' 에 대해 더미변수화
name = ['continent', 'position', 'prefer_foot']
dummies = pd.get_dummies(apps[name], drop_first=True)
fifa = pd.concat([data, dummies], axis=1).drop(name, axis=1)
final_df = pd.get_dummies(fifa, columns=['reputation','stat_skill_moves'], drop_first=True)

# 각각의 범주의 수에 맞게 더미변수화 된 것을 확인할 수 있음
final_df.info()